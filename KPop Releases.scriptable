{
  "always_run_in_app" : false,
  "icon" : {
    "color" : "pink",
    "glyph" : "calendar-alt"
  },
  "name" : "KPop Releases",
  "script" : "\/\/ KPop Releases Widget by heismauri\n\n\/\/ Utilities\nconst addLeadingZero = (number) => {\n  return `0${number}`.slice(-2);\n};\n\nconst formatAMPM = (date) => {\n  let hours = date.getHours();\n  const minutes = addLeadingZero(date.getMinutes());\n  const ampm = hours >= 12 ? 'PM' : 'AM';\n  hours %= 12;\n  hours = hours || 12;\n  hours = addLeadingZero(hours);\n  return `${hours}:${minutes}${ampm}`;\n};\n\nconst formatTime = (date) => {\n  const hours = addLeadingZero(date.getHours());\n  const minutes = addLeadingZero(date.getMinutes());\n  return `${hours}:${minutes}`;\n};\n\nconst formatDate = (date) => {\n  const day = addLeadingZero(date.getDate());\n  const month = addLeadingZero(date.getMonth() + 1);\n  return [[day, month].join('.'), formatAMPM(date)];\n};\n\nconst getKeyByValue = (object, value) => {\n  return Object.keys(object).find((key) => Object.values(object[key]).indexOf(value) > -1);\n};\n\nconst groupByDateAndLimit = (releases, limit) => {\n  return releases.slice(0, limit).reduce((accumulator, release) => {\n    const key = release.date;\n    accumulator[key] = accumulator[key] || [];\n    accumulator[key].push(release.title);\n    return accumulator;\n  }, {});\n};\n\n\/\/ HTML Preview\nconst encodeString = (text) => {\n  return text.replace(\/[\\u00A0-\\u9999<>\\&]\/gim, (i) => '&#' + i.charCodeAt(0) + ';');\n};\n\nconst releasesToHTML = (releases) => {\n  return Object.keys(releases).map((day) => {\n    const [date, time] = formatDate(new Date(parseInt(day, 10)));\n    const title = `<ul class=\"calendar-day\"><li class=\"calendar-day-date\"><strong>${date}<\/strong><i>${time}<\/i><\/li>`;\n    const listElements = releases[day].map((release) => {\n      return `<li>${encodeString(release)}<\/li>`;\n    });\n    return [title, '<ul class=\"calendar-day-events\">', ...listElements, '<\/ul><\/li><\/ul>'].join('');\n  }).join('');\n};\n\nconst HTMLBuilder = (releases) => {\n  return `\n    <!DOCTYPE html>\n    <html>\n      <head>\n        <meta http-equiv=\"Content-Type\" content=\"text\/html; charset=utf-8\">\n        <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\n        <title>KPop Upcoming Releases<\/title>\n        <style>\n          *{box-sizing:border-box}body{margin:0;color:#3c4142;font-size:1rem;font-family:-apple-system,'SF Pro Text','SF Pro Icons','Helvetica Neue','Helvetica','Arial',sans-serif;line-height:1.5}.calendar-day{margin:1rem 0;padding:0;list-style-type:none}.calendar-day-events{padding-left:2rem}.container{width:100%;max-width:30rem;padding:0 2rem;margin:0 auto}h1{color:#ce5891;text-transform:uppercase;margin-top:0;margin-bottom:.5rem;font-weight:bold;font-size:1rem}.calendar-day-date i{font-style:normal;margin-left:.25rem;opacity:.5}@media(prefers-color-scheme:dark){body{background:#201c1c;color:#fff}}\n        <\/style>\n      <\/head>\n      <body>\n      <div class=\"container\">\n      <h1>ðŸ«° KPop Upcoming Releases<\/h1>\n      ${releasesToHTML(releases)}\n      <\/div>\n      <\/body>\n    <\/html>\n  `;\n};\n\n\/\/ Cache API\nconst fm = FileManager.iCloud();\nconst dir = fm.joinPath(fm.documentsDirectory(), 'kpop-releases-cache');\nif (!fm.fileExists(dir)) fm.createDirectory(dir);\nconst apiCache = fm.joinPath(dir, 'api.json');\n\n\/\/ Get releases\nconst getReleasesAPI = async () => {\n  const request = new Request('https:\/\/gateway.reddit.com\/desktopapi\/v1\/subreddits\/kpop?include=structuredStyles');\n  const json = await request.loadJSON();\n  const allWidgets = json.structuredStyles.data.content.widgets.items;\n  const releasesWidgetKey = getKeyByValue(allWidgets, 'Upcoming Releases');\n  const allUpcomingReleases = allWidgets[releasesWidgetKey].data.map((release) => {\n    return {\n      title: release.title.split(' - ').filter((i) => i).join(' - '),\n      date: release.startTime * 1000\n    };\n  });\n  fm.writeString(apiCache, JSON.stringify(allUpcomingReleases.sort((a, b) => a.date - b.date)));\n};\n\nconst getReleases = async (limit) => {\n  if (!fm.fileExists(apiCache)) await getReleasesAPI();\n  await fm.downloadFileFromiCloud(apiCache);\n  const content = await JSON.parse(fm.readString(apiCache));\n  const timestamp = content.at(0).date;\n  const oneHourAgo = new Date() - (4.2 * 10 ** 6);\n  if (new Date(oneHourAgo) > new Date(parseInt(timestamp, 10))) {\n    await getReleasesAPI();\n    await getReleases();\n  }\n  return groupByDateAndLimit(content, limit);\n};\n\n\/\/ Set limit based on Widget size\nlet limit;\nswitch (config.widgetFamily) {\n  case 'small':\n    limit = 2;\n    break;\n  case 'medium':\n    limit = 3;\n    break;\n  default:\n    limit = 10;\n}\n\/\/ Ignore limit when script is run inside Scriptable\nif (config.runsInWidget) limit = parseInt(args.widgetParameter, 10) || limit;\n\n\/\/ Run get releases\nconst releases = await getReleases(limit);\n\n\/\/ Widget\nconst PADDING = 15;\n\nconst widget = new ListWidget();\nwidget.setPadding(PADDING, 12, PADDING, PADDING);\nwidget.backgroundColor = Color.dynamic(new Color('#ffffff'), new Color('#201c1c'));\n\nconst widgetTitle = widget.addText('ðŸ«° KPOP RELEASES');\nwidgetTitle.font = Font.semiboldSystemFont(12);\nwidgetTitle.textColor = new Color('#ce5891');\n\nconst mainStack = widget.addStack();\nmainStack.setPadding(0, 3, 0, 0);\nmainStack.topAlignContent();\nmainStack.layoutVertically();\n\nmainStack.addSpacer();\n\n\/\/ Print each release by day\nObject.keys(releases).forEach((day) => {\n  const dateStack = mainStack.addStack();\n  dateStack.layoutHorizontally();\n  const [date, time] = formatDate(new Date(parseInt(day, 10)));\n  const dateText = dateStack.addText(date);\n  dateText.font = Font.semiboldSystemFont(13);\n  dateStack.addSpacer(4);\n  const timeText = dateStack.addText(time);\n  timeText.font = Font.regularSystemFont(13);\n  timeText.textOpacity = 0.5;\n  const spaceBetweenDates = Object.keys(releases).at(-1) === day ? 0 : 4;\n  releases[day].forEach((release) => {\n    const releaseStack = mainStack.addStack();\n    const releaseText = releaseStack.addText(release);\n    releaseText.font = Font.regularSystemFont(13);\n  });\n  mainStack.addSpacer(spaceBetweenDates);\n});\n\nmainStack.addSpacer();\n\n\/\/ Generate Alert\nconst generateAlert = async (options) => {\n  let alert = new Alert();\n  alert.message = 'What would you like to do?';\n  options.forEach((option) => {\n    alert.addAction(option);\n  });\n  return await alert.presentAlert();\n};\n\n\/\/ Preview widget in large\nif (!config.runsInWidget) {\n  const options = ['View all upcoming releases', 'Clear cache'];\n  const response = await generateAlert(options);\n  if (response === 0) {\n    const webView = new WebView();\n    webView.loadHTML(HTMLBuilder(await getReleases()));\n    await webView.present();\n  };\n  if (response === 1) {\n    await getReleasesAPI();\n  };\n};\n\nScript.setWidget(widget);\nScript.complete();\n",
  "share_sheet_inputs" : [

  ]
}