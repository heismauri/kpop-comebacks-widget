{
  "always_run_in_app" : false,
  "icon" : {
    "color" : "pink",
    "glyph" : "calendar-alt"
  },
  "name" : "KPop Releases",
  "script" : "\/\/ KPop Releases Widget by heismauri\n\n\/\/ Utilities\nconst addLeadingZero = (number) => {\n  return `0${number}`.slice(-2);\n};\n\nconst formatAMPM = (date) => {\n  let hours = date.getHours();\n  const minutes = addLeadingZero(date.getMinutes());\n  const ampm = hours >= 12 ? 'PM' : 'AM';\n  hours %= 12;\n  hours = hours || 12;\n  hours = addLeadingZero(hours);\n  return `${hours}:${minutes}${ampm}`;\n};\n\nconst formatTime = (date) => {\n  const hours = addLeadingZero(date.getHours());\n  const minutes = addLeadingZero(date.getMinutes());\n  return `${hours}:${minutes}`;\n};\n\nconst formatDate = (date) => {\n  const day = addLeadingZero(date.getDate());\n  const month = addLeadingZero(date.getMonth() + 1);\n  return [[day, month].join('.'), formatAMPM(date)];\n};\n\nconst getKeyByValue = (object, value) => {\n  return Object.keys(object).find((key) => Object.values(object[key]).indexOf(value) > -1);\n};\n\nconst groupByDateAndLimit = (releases, limit) => {\n  let updatedReleases = releases.sort((a, b) => a.date - b.date);\n  if (limit !== undefined) updatedReleases = updatedReleases.slice(0, limit);\n  return updatedReleases.reduce((accumulator, release) => {\n    const key = release.date;\n    accumulator[key] = accumulator[key] || [];\n    accumulator[key].push(release.title);\n    return accumulator;\n  }, {});\n};\n\n\/\/ Cache API\nconst fm = FileManager.iCloud();\nconst dir = fm.joinPath(fm.documentsDirectory(), 'kpop-releases-cache');\nif (!fm.fileExists(dir)) fm.createDirectory(dir);\nconst apiCache = fm.joinPath(dir, 'api.json');\n\n\/\/ Get releases\nconst getReleasesAPI = async () => {\n  const request = new Request('https:\/\/gateway.reddit.com\/desktopapi\/v1\/subreddits\/kpop?include=structuredStyles');\n  const json = await request.loadJSON();\n  const allWidgets = json.structuredStyles.data.content.widgets.items;\n  const releasesWidgetKey = getKeyByValue(allWidgets, 'Upcoming Releases');\n  const allUpcomingReleases = allWidgets[releasesWidgetKey].data.map((release) => {\n    return {\n      \/\/ Clean releases with only artists\n      title: release.title.split(' - ').filter((i) => i).join(' - '),\n      date: release.startTime * 1000\n    };\n  });\n  fm.writeString(apiCache, JSON.stringify(allUpcomingReleases));\n};\n\nconst getReleases = async (limit) => {\n  if (!fm.fileExists(apiCache)) await getReleasesAPI();\n  await fm.downloadFileFromiCloud(apiCache);\n  const content = await JSON.parse(fm.readString(apiCache));\n  const timestamp = content.sort((a, b) => a.date - b.date).at(0).date;\n  const oneHourAgo = new Date() - (4.2 * 10 ** 6);\n  if (new Date(oneHourAgo) > new Date(parseInt(timestamp, 10))) {\n    await getReleasesAPI();\n    await getReleases();\n  }\n  return groupByDateAndLimit(content, limit);\n};\n\n\/\/ Set limit based on Widget size\nlet limit;\nswitch (config.widgetFamily) {\n  case 'small':\n    limit = 2;\n    break;\n  case 'medium':\n    limit = 3;\n    break;\n  default:\n    limit = 10;\n}\n\/\/ Ignore limit when script is run inside Scriptable\nif (config.runsInWidget) limit = parseInt(args.widgetParameter, 10) || limit;\n\n\/\/ Run get releases\nconst releases = await getReleases(limit);\n\n\/\/ Widget\nconst PADDING = 15;\n\nconst widget = new ListWidget();\nwidget.setPadding(PADDING, 12, PADDING, PADDING);\nwidget.backgroundColor = Color.dynamic(new Color('#ffffff'), new Color('#201c1c'));\n\nconst widgetTitle = widget.addText('ðŸ«° KPOP RELEASES');\nwidgetTitle.font = Font.semiboldSystemFont(12);\nwidgetTitle.textColor = new Color('#ce5891');\n\nconst mainStack = widget.addStack();\nmainStack.setPadding(0, 3, 0, 0);\nmainStack.topAlignContent();\nmainStack.layoutVertically();\n\nmainStack.addSpacer();\n\n\/\/ Print each release by day\nObject.keys(releases).forEach((day) => {\n  const dateStack = mainStack.addStack();\n  dateStack.layoutHorizontally();\n  const [date, time] = formatDate(new Date(parseInt(day, 10)));\n  const dateText = dateStack.addText(date);\n  dateText.font = Font.semiboldSystemFont(13);\n  dateStack.addSpacer(4);\n  const timeText = dateStack.addText(time);\n  timeText.font = Font.regularSystemFont(13);\n  timeText.textOpacity = 0.5;\n  const spaceBetweenDates = Object.keys(releases).at(-1) === day ? 0 : 4;\n  releases[day].forEach((release) => {\n    const releaseStack = mainStack.addStack();\n    const releaseText = releaseStack.addText(release);\n    releaseText.font = Font.regularSystemFont(13);\n  });\n  mainStack.addSpacer(spaceBetweenDates);\n});\n\nmainStack.addSpacer();\n\n\/\/ Preview widget in large\nif (!config.runsInWidget) {\n  await widget.presentLarge();\n};\n\nScript.setWidget(widget);\nScript.complete();\n",
  "share_sheet_inputs" : [

  ]
}